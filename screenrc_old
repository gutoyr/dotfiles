##################################
#
# Author: Gustavo Yokoyama Ribeiro
# File:   .screenrc
# Update: 20090925 08:57:27
# (C) Copyright 2010 Gustavo Yokoyama Ribeiro
# Licensed under CreativeCommons Attribution-ShareAlike 3.0 Unsupported
# http://creativecommons.org/licenses/by-sa/3.0/ for more info.
#
##################################


# explicações sobre as configurações e utilização geral do screen
# estão em http://aurelio.net/doc/coluna

# ------------------------------------------------------------------------------
# TERMINAL/SCREEN SETTINGS {{{1
# ------------------------------------------------------------------------------

autodetach on

altscreen on # get rid of content on the window left by programs, for instance,Vim

multiuser off
startup_message off
msgminwait 0          # the first message is ignored.
msgwait 10             # the last message is displayed for 10 seconds or
#nethack on           # msgs estilo nethack
#sorendition "+b wk"   # Make screen messages stand out a little more - white on black.
activity "%c activity -> %n%f %t"
bell_msg "%c:bell -> %n%f %t"
vbell on
vbell_msg "%c:bell -> %n%f %t"
vbellwait 3

# Keep dead windows around until I tell them to exit.
#zombie kr

# And show the command for the windows when they're resurrected.
verbose on

# If a window goes unresponsive, don't block the whole session waiting for it.
nonblock on

defscrollback 20000                 # define scroll back buffer size in copy/scroll mode

# see at EOF
caption splitonly                   # window bar
caption string "[%n %t] %h"
#caption string "%?%F%{Wb}%?---<%n %t>---%{-}"

#hardstatus on
#hardstatus alwayslastline
hardstatus string "%-Lw%{Wr}%50>-<<%n %t>>-%{-}%+Lw%<"
#hardstatus string "%?%F%{.R.}%?%3n %t%? [%h]%?"
#hardstatus string "%=%-Lw%{Wr}(%n %t)%{-}%+Lw %=[%d/%m %c]"
#hardstatus string "[%H]%=%-Lw%{Wr}-<<%n %t>>-%{-}%+Lw %=[%d/%m %c]"
#hardstatus string "%=%-Lw%{wk}-<<%n %t>>-%{-}%+Lw %="
#hardstatus string '%{= kG}[ %{G}%H %{g}][%= %{= kw}%?%-Lw%?%{r}(%{W}%n*%f%t%?(%u)%?%{r})%{w}%?%+Lw%?%?%= %{g}][%{B} %d/%m %{W}%c %{g}]'

ignorecase on                       # ignore case for search in copy mode
compacthist on                      # trailing blank lines when scroll up

# force to read .login, i.e., full initialisation (read .zlogin and .zshrc).
#shell -$SHELL
#colocar \033k\033\134 no começo do PS1
# permite prompt colorido mas bagunça quando chega na extrema direita

# permite ter o comando executado no title do xterm
#shelltitle '$ |bash'
shelltitle '$ |zsh'
shell /bin/zsh
bind R screen -t "# |root:" su

# PASSWORD
# ===============================================================
# This commands sets the *internal* password for the screen session.
# WARNING!! If this is set then a "lock" command will only let you in to the
# session after you enter the user's account password and then *also*
# the internal password for that session. This gives additional safety but,
# if you forget the internal password then you cannot resume your session.
# Use :password to generate a password
#password ODSJQf.4IJN7E

# emulate .logout message
pow_detach_msg "Screen session of \$LOGNAME \$:cr:\$:nl:ended."

#escape ``

# initialization
screen
screen
screen
select 0

#}}}1
# ------------------------------------------------------------------------------
# SCREEN KEYBINDINGS {{{1
# ------------------------------------------------------------------------------

# Safety {{{2
# Remove some stupid / dangerous key bindings
# kill
bind k
bind 
# suspend
bind z
bind ^z
# lockscreen
bind x
bind ^x
# kill all
bind ''
# syspend (xoff)
bind s


# Key Map {{{2
#bind b screen -t '$ |rdlxbd01:' ssh rdlxbd01
#bind u screen -T xterm -t '$ |rdux028:' ssh rdux028

# Copy/Paste {{{2
# Prepend/append register [/] to the paste if ^a^] is pressed.
# This lets me have autoindent mode in vi.
#register [ "\033:se noai\015a"
#register ] "\033:se ai\015a"
#bind ^] paste [.]
#bind p paste [.]
bind p paste .

# Region {{{2
bind s split
bind v split -v
bind x remove
bind o only
bind k focus up
bind j focus down
bindkey [1;3A focus up
bindkey [1;3B focus down
# Resize map
#bind 'R' wrap
bind r resize
bind = resize =
bind + resize +5
bind - resize -5

# Window {{{2
# F1=F11 k1=F1
bindkey -k k1 prev
bindkey [1;3D prev
bindkey -k k2 next
bindkey [1;3C next

# Others {{{2
bindkey "Ol" stuff +
bindkey "OS" stuff -
bindkey "OR" stuff *
bindkey "OQ" stuff /
# Bind F10 (k;) to escape ctrl-a
#bindkey -k k; command

bind d detach
bind K kill   # kill command

#bind e hardstatus ignore "%-Lw%{Wr}%50>-<<%n %t>>-%{-}%+Lw%<"
#bind g hardstatus alwayslastline "%{= rk} %=%-Lw%{Wk}(%n %t)%{-}%+Lw %=[%d/%m %c]"
bindkey -k k9 hardstatus ignore "%-Lw%{Wr}%50>-<<%n %t>>-%{-}%+Lw%<"
bindkey -k k; hardstatus alwayslastline "%{= Ck} %=%-Lw%{Wk}(%n %t)%{-}%+Lw %=[%d/%m %c]"

# enquanto não resolver o problema do hardcopy com hardstatus
#hardcopy_append on
#bind h

# to shit+(page up|page down) work
# tell screen that you term can scroll
termcapinfo xterm ti@:te@
# bind Shift+PgUp/PgDn
bindkey -m "^[[5;2~" stuff ^b
bindkey -m "^[[6;2~" stuff ^f
#}}}2
#}}}1
# ------------------------------------------------------------------------------
# XTERM TWEAKS {{{1
# ------------------------------------------------------------------------------
# set these terminals up to be 'optimal' instead of vt100
#termcapinfo xterm*|linux*|rxvt*|Eterm* OP


### do /etc/screenrc
#termcap  facit|vt100|xterm LP:G0
#terminfo facit|vt100|xterm LP:G0
#the vt100 description does not mention "dl". *sigh*
#termcap  vt100 dl=5\E[M
#terminfo vt100 dl=5\E[M
###

#facit's "al" / "dl"  are buggy if the current / last line
#contain attributes...
#termcap  facit al=\E[L\E[K:AL@:dl@:DL@:cs=\E[%i%d;%dr:ic@
#terminfo facit al=\E[L\E[K:AL@:dl@:DL@:cs=\E[%i%p1%d;%p2%dr:ic@

#make sun termcap/info better
#termcap  sun 'up=^K:AL=\E[%dL:DL=\E[%dM:UP=\E[%dA:DO=\E[%dB:LE=\E[%dD:RI=\E[%dC:IC=\E[%d@:WS=1000\E[8;%d;%dt'
#terminfo sun 'up=^K:AL=\E[%p1%dL:DL=\E[%p1%dM:UP=\E[%p1%dA:DO=\E[%p1%dB:LE=\E[%p1%dD:RI=\E[%p1%dC:IC=\E[%p1%d@:WS=\E[8;%p1%d;%p2%dt$<1000>'

# Long time I had this in my private screenrc file. But many people
# seem to want it (jw):
# we do not want the width to change to 80 characters on startup:
# on suns, /etc/termcap has :is=\E[r\E[m\E[2J\E[H\E[?7h\E[?1;3;4;6l:
#termcap xterm 'is=\E[r\E[m\E[2J\E[H\E[?7h\E[?1;4;6l'
#terminfo xterm 'is=\E[r\E[m\E[2J\E[H\E[?7h\E[?1;4;6l'

#
# Do not use xterms alternate window buffer.
# This one would not add lines to the scrollback buffer.
#termcap xterm|xterms|xs ti=\E7\E[?47l
#terminfo xterm|xterms|xs ti=\E7\E[?47l

# ===============================================================

# xterm understands both im/ic and doesn't have a status line.
# Note: Do not specify im and ic in the real termcap/info file as
# some programs (e.g. vi) will not work anymore.
#termcap  xterm hs@:cs=\E[%i%d;%dr:im=\E[4h:ei=\E[4l
#terminfo xterm hs@:cs=\E[%i%p1%d;%p2%dr:im=\E[4h:ei=\E[4l

# 80/132 column switching must be enabled for ^AW to work
# change init sequence to not switch width
#termcapinfo  xterm Z0=\E[?3h:Z1=\E[?3l:is=\E[r\E[m\E[2J\E[H\E[?7h\E[?1;4;6l

# Make the output buffer large for (fast) xterms.
#termcapinfo xterm* OL=10000

# tell screen that xterm can switch to dark background and has function
# keys.
#termcapinfo xterm 'VR=\E[?5h:VN=\E[?5l'
#termcapinfo xterm 'k1=\E[11~:k2=\E[12~:k3=\E[13~:k4=\E[14~'
#termcapinfo xterm 'kh=\EOH:kI=\E[2~:kD=\E[3~:kH=\EOF:kP=\E[5~:kN=\E[6~'

# special xterm hardstatus: use the window title.
#termcapinfo xterm 'hs:ts=\E]2;:fs=\007:ds=\E]2;screen\007'
#termcapinfo xterm 'hs:ts=\E]2;:fs=\007:ds=\E]1;screen\007'

#terminfo xterm 'vb=\E[?5h$<200/>\E[?5l'
#termcapinfo xterm 'vi=\E[?25l:ve=\E[34h\E[?25h:vs=\E[34l'

# emulate part of the 'K' charset
#termcapinfo xterm 'XC=K%,%\E(B,[\304,\\\\\326,]\334,{\344,|\366,}\374,~\337'

# xterm-52 tweaks:
# - uses background color for delete operations
#termcapinfo xterm ut
#termcapinfo xterm* be

# pgup pgdn for xterm
#termcapinfo xterm*|rxvt* 'ti@:te@'

# Extend the vt100 desciption by some sequences.
#termcap  vt100* ms:AL=\E[%dL:DL=\E[%dM:UP=\E[%dA:DO=\E[%dB:LE=\E[%dD:RI=\E[%dC
#terminfo vt100* ms:AL=\E[%p1%dL:DL=\E[%p1%dM:UP=\E[%p1%dA:DO=\E[%p1%dB:LE=\E[%p1%dD:RI=\E[%p1%dC
#termcapinfo linux C8

# Matthias Kopfermann <matthias_kopfermann@gmx.de> [020222]
# make the cursor show up in red:
#termcapinfo linux "ve=\E[?25h\E[?17;0;64c" # red

#The tweaks for the color xterm
# AF (setaf) = Set foreground color (ANSI compatible)
# AB (setab) = Set background color (ANSI compatible)
# AX         = Does have ANSI set default fg/bg color (\E[39m / \E[49m)
#termcap  xterm 'AF=\E[3%dm:AB=\E[4%dm'
#terminfo xterm 'AF=\E[3%p1%dm:AB=\E[4%p1%dm'


################
#
# 256 colours
#
# ... http://frexx.de/xterm-256-notes/
#

# terminfo and termcap for nice 256 color terminal
# allow bold colors - necessary for some reason
attrcolor b ".I"
# tell screen how to set colors. AB = background, AF=foreground
termcapinfo xterm 'Co#256:AB=\E[48;5;%dm:AF=\E[38;5;%dm'
termcapinfo xterm-color "Co#256:AB=\E[48;5;%dm:AF=\E[38;5;%dm"
# erase background with current bg color
#defbce "on"

#term "screen-256color"

################
#
# wyse terminals
#

#wyse-75-42 must have flow control (xo = "terminal uses xon/xoff")
#essential to have it here, as this is a slow terminal.
#termcapinfo wy75-42 xo:hs@

# New termcap sequences for cursor application mode.
#termcapinfo wy* CS=\E[?1h:CE=\E[?1l:vi=\E[?25l:ve=\E[?25h:VR=\E[?5h:VN=\E[?5l:cb=\E[1K:CD=\E[1J

termcapinfo xterm 'hs:ts=\E]2;:fs=\007:ds=\E]2;screen\007'

#}}}1
# ------------------------------------------------------------------------------
# vim: ft=sh ff=unix fdm=marker :
